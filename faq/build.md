# 面试题（工程化）

## CI/CD

持续集成持续部署，以前测试、构建、部署等操作都是手动操作，现在可以通过自动化的方式代替，开发人员只需要关注代码的开发即可

我们项目分为测试环境或和生产环境，开发流程如下：

- 开发人员从开发分支创建功能分支
- 开发完成并自测后合并到开发分支，触发流水线自动构建部署
- 测试人员可以在测试环境测试通过后
- 发起合并请求到主分支，经过代码审核后合并到主分支
- 主分支通过打标签的方式触发流水线，成功后部署到生产环境上

在代码提交前，我们会使用`ESLint`代码进行检查，检查内容如下：

- 集成`prettier `对代码格式化
- 集成`cspell` 对单词检查
- 以及 vue、js等一些推荐规则或者自定义的一些规则

一般只对暂存区的代码进行检查，主要是通过 `lint-stage` 和 `husky` 实现

- 创建 `.lintstagedrc.json` 配置文件，配置需要执行的命令 `eslint --fix`
- 创建 `.husky/pre-commit` 配置指令 `npx lint-stage`



## 常用插件

```
vite-plugin-compression：可以将生成的文件进行zip压缩，减少文件的大小

vite-plugin-imagemin：可以将图片文件进行压缩，减少文件的大小

vite-plugin-inspect：可视化查看 Vite 的构建过程和性能指标

vite-plugin-auto-import： 来自动导入常用的 API 和组件
```



## Vite vs Webpack

```
webpack会在构建过程中吧所有模块（包括 js、css、image...）都分析打包。

开发模式下，当修改文件时都需要重新构建整个模块依赖图。
如果是大型项目，存在多个相互依赖模块，它会从入口文件开始，
递归解析每个模块的依赖关系，然后将其打包成一个或多个bundle文件。

这将导致即使修改一个小模块，它也要处理很多模块，构建速度会随着项目增大而变慢。
```

```
vite利用现代浏览器支持ESM的特性。在开发模式下，它无需提前打包所有模块。

相反，它会在浏览器请求某个模块时才会去解析和转换这个模块。
例如浏览器请求vue文件时，可浏览器根本无法识别vue文件，
此时vite会在服务端将该文件转为浏览器可识别的格式并返回给浏览器。

这种按需加载的方式使得开发过程中，启动速度非常快，因为它无需一开始做大量的打包工作。
```



## esbuild vs rollup

开发环境：esbuild 进能够行快速的热重载和模块编译可以显著提高开发体验。

生产环境：rollup 擅长于生成优化后的静态资源，如代码压缩、Tree Shaking 等。

::: tip 为什么vite 两者都用

Vite 在开发环境中使用 esbuild 进行快速的热重载和模块编译，而在生产环境中使用 Rollup 进行最终的打包和优化。这是为了平衡开发效率和构建性能。

esbuild 的优点在于其极高的构建速度，这使得 Vite 在开发过程中能够提供极快的响应速度和即时反馈。然而，esbuild 在某些复杂的构建场景（如代码拆分、插件扩展等）中可能不如 Rollup 灵活

:::

**Rollup 优点**

```
Tree Shaking：可以删除未使用的代码，从而减小打包后的文件体积。

代码拆分：支持代码拆分，可以将代码分割成多个块（chunks），然后按需加载

模块化打包：支持 ESM ，可以将模块化的代码打包成各种格式，如 CommonJS、UMD、IIFE 等

插件系统：拥有一个丰富的插件生态系统，允许用户自定义构建过程

优化和压缩：支持多种优化和压缩选项，可以生成更小、更快的代码

兼容性：支持 ES6+ 的最新特性，包括类、箭头函数、模板字符串等
```

**esbuild 优点**

```
极快的构建速度Go 语言编写的，这使得它在执行任务时非常快速

原生 TypeScript 支持：原生支持 TypeScript，无需额外的配置或插件

ESM 和 CommonJS 支持：支持 ESM 和 CommonJS 模块格式，可以处理各种不同的模块化需求

Tree Shaking：e支持 Tree Shaking，可以删除未使用的代码，从而减小打包后的文件体积

压缩和优化：可以对 JavaScript 代码进行压缩和优化，包括去除空格、注释、内联函数等

轻量级：轻量级的工具，安装和运行都非常快速。这使得它非常适合在 CI/CD 流程中使用
```

